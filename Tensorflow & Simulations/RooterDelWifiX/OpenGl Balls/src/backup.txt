#include <C:\Users\Root\Desktop\OPENGL\OpenGl\include\glad\glad.h>
#include <C:\Users\Root\Desktop\OPENGL\OpenGl\include\GLFW\glfw3.h>
#include <C:\Users\Root\Desktop\OPENGL\OpenGl\include\glm\glm\glm.hpp>
#include <C:\Users\Root\Desktop\OPENGL\OpenGl\include\glm\glm\gtc\matrix_transform.hpp>
#include <C:\Users\Root\Desktop\OPENGL\OpenGl\include\glm\glm\gtc\type_ptr.hpp>
#include <iostream>
#include <conio.h>
#include <cmath>

const char* vertexShaderSource =
"#version 330 core\n"
"layout (location = 0) in vec3 Pos;\n"
"uniform mat4 Transform; \n"
"void main()\n"
"{\n"
"   gl_Position = Transform * vec4(Pos, 1.0f);\n"
"}\0";
const char* fragmentShaderSource = "#version 330 core\n"
"out vec4 color;\n"
"void main()\n"
"{\n"
"   color = vec4(1.0f, 0.3f, 0.4f, 1.0f); \n"
"}\n\0"; 

void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
 glViewport(0, 0, width, height);
}
int main()
{
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
   GLfloat vertices[] = {
   -0.5f, -0.5f, -0.5f,
   0.5f, -0.5f, -0.5f,
   0.5f, 0.5f, -0.5f,
   0.5f, 0.5f, -0.5f,
   -0.5f, 0.5f, -0.5f,
   -0.5f, -0.5f, -0.5f,
   -0.5f, -0.5f, 0.5f,
   0.5f, -0.5f, 0.5f,
   0.5f, 0.5f, 0.5f,
    0.5f, 0.5f, 0.5f,
    -0.5f, 0.5f, 0.5f,
    -0.5f, -0.5f, 0.5f,
    -0.5f, 0.5f, 0.5f,
    -0.5f, 0.5f, -0.5f,
    -0.5f, -0.5f, -0.5f,
    -0.5f, -0.5f, -0.5f,
    -0.5f, -0.5f, 0.5f,
    -0.5f, 0.5f, 0.5f, 
    0.5f, 0.5f, 0.5f,
    0.5f, 0.5f, -0.5f,
    0.5f, -0.5f, -0.5f,
    0.5f, -0.5f, -0.5f,
    0.5f, -0.5f, 0.5f,
    0.5f, 0.5f, 0.5f,
    -0.5f, -0.5f, -0.5f,
    0.5f, -0.5f, -0.5f,
    0.5f, -0.5f, 0.5f,
    0.5f, -0.5f, 0.5f, 
    -0.5f, -0.5f, 0.5f, 
    -0.5f, -0.5f, -0.5f,
     -0.5f, 0.5f, -0.5f, 
      0.5f, 0.5f, -0.5f, 
      0.5f, 0.5f, 0.5f,
      0.5f, 0.5f, 0.5f,
     -0.5f, 0.5f, 0.5f,
     -0.5f, 0.5f, -0.5f
    };
    GLFWwindow* window = glfwCreateWindow(800, 800, "Hola Windows", NULL, NULL);
    if(window == NULL)
    {
      std::cout <<"Failed to create GLFW Window"<<std::endl;
      glfwTerminate();
      return -1;
    }
    glfwMakeContextCurrent(window);
    //code goes here
    gladLoadGL();
    glViewport(0, 0, 800, 800);
    GLuint shaderProgram = glCreateProgram();
    GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
    glCompileShader(vertexShader);

    int success;
    char infoLog[512];
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
    if(!success)
    {
    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
    std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" <<infoLog << std::endl;
    }   

    GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
    glCompileShader(fragmentShader);

    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);

    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);
    
    GLuint VAO,VBO;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);
    glBindVertexArray(VAO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_DYNAMIC_DRAW);
    //atributes

    //Positions
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3*sizeof(float), (const void*)0);
    //Colors 7w7
    glEnableVertexAttribArray(0);

    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);

    glClearColor(0.07f, 0.13f, 0.17f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);
    glfwSwapBuffers(window);

    glPolygonMode(GL_FRONT_AND_BACK,GL_LINE);

    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    glUseProgram(shaderProgram);
    //transforms
    glm::mat4 model = glm::mat4(1.0f);
    model = glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0, 0.0, 0.0));
    //model = glm::scale(model, glm::vec3(0.25, 0.25, 0.25));
    glm::mat4 view = glm::mat4(1.0f);
    view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f));
    glm::mat4 projection;
    projection = glm::perspective(glm::radians(45.0f), (800.0f/800.0f), 0.1f, 100.0f);
    //trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5));
  GLuint TRANSFORM = glGetUniformLocation(shaderProgram, "Transform"); 
    glUniformMatrix4fv(TRANSFORM, 1, GL_FALSE, glm::value_ptr(projection * view * model));  

    while (!glfwWindowShouldClose(window))
    {
      //glClearColor(0.07f, 0.13f, 0.17f, 1.0f);
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
      glUseProgram(shaderProgram);
      model = glm::rotate(model, glm::radians(-0.8f), glm::vec3(1.0, 0.0, 0.0));
      model = glm::rotate(model, glm::radians(-0.5f), glm::vec3(0.0, 1.0, 0.0));
      GLuint TRANSFORM = glGetUniformLocation(shaderProgram, "Transform"); 
      glUniformMatrix4fv(TRANSFORM, 1, GL_FALSE, glm::value_ptr(projection * view * model));
      glEnable(GL_DEPTH_TEST);
      glBindVertexArray(VAO);
      glDrawArrays(GL_TRIANGLES, 0, 6);
      //glDrawArrays(GL_LINE_STRIP, 0, 36);
      //glDrawArrays(GL_POINT_SMOOTH, 0, 6);
      glfwSwapBuffers(window);
      glfwPollEvents();
    }
    glDeleteVertexArrays(1, &VAO);
    glDeleteBuffers(1, &VBO);
    glDeleteProgram(shaderProgram);
    glfwDestroyWindow(window);
    glfwTerminate();
   return 0;
}